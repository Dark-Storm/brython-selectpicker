__BRYTHON__.VFS_timestamp = 1629282922138
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1629282922138, "browser": [".py", "", [], 1], "browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]], "browser.html": [".py", "from _html import *\n", ["_html"]], "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(isinstance(val, list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key,str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(typeof xhr.response == \"string\"){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes)\n    if(req.mode == \"binary\"){\n        return b\n    }else if(req.mode == \"document\"){\n        return $B.JSObj.$factory(xhr.response)\n    }else{\n        var encoding = req.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        encoding,\n        headers={},\n        cache,\n        mode = \"text\",\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(params.__class__ === _b_.dict){\n                for(var key in params.$numeric_dict){\n                    throw _b_.ValueError.$factory(\n                        'data only supports string keys, got ' + key)\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(params))\n            }\n        }else if(key == \"encoding\"){\n            encoding = kw.$string_dict[key][0]\n        }else if(key == \"headers\"){\n            var value = kw.$string_dict[key][0]\n            if(! _b_.isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(key in value.$string_dict){\n                headers[key.toLowerCase()] = [key, value.$string_dict[key][0]]\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                var f = kw.$string_dict[key][0]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = kw.$string_dict[key][0]\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n    return {cache, data, encoding, headers, mode, timeout}\n}\n\nvar ajax = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n\n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n\n    $infos: {\n        __module__: \"builtins\",\n        __name__: \"ajax\"\n    },\n\n    __getattribute__: function(self, attr){\n        if(ajax[attr] !== undefined){\n            return function(){\n                return ajax[attr].call(null, self, ...arguments)\n            }\n        }else if(attr == \"text\"){\n            return _read(self)\n        }else if(attr == \"json\"){\n            if(self.js.responseType == \"json\"){\n                return _read(self)\n            }else{\n                var resp = _read(self)\n                try{\n                    return $B.structuredclone2pyobj(JSON.parse(resp))\n                }catch(err){\n                    console.log('attr json, invalid resp', resp)\n                    throw err\n                }\n            }\n        }else if(self.js[attr] !== undefined){\n            if(typeof self.js[attr] == \"function\"){\n                return function(){\n                    if(attr == \"setRequestHeader\"){\n                        ajax.set_header.call(null, self, ...arguments)\n                    }else{\n                        if(attr == 'overrideMimeType'){\n                            console.log('override mime type')\n                            self.hasMimeType = true\n                        }\n                        return self.js[attr](...arguments)\n                    }\n                }\n            }else{\n                return self.js[attr]\n            }\n        }else if(attr == \"xml\"){\n            return $B.JSObj.$factory(self.js.responseXML)\n        }\n    },\n\n    bind: function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on' + evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n        return _b_.None\n    },\n\n    open: function(){\n        var $ = $B.args('open', 4,\n                {self: null, method: null, url: null, async: null},\n                ['self', 'method', 'url', 'async'], arguments,\n                {async: true}, null, null),\n            self = $.self,\n            method = $.method,\n            url = $.url,\n            async = $.async\n        self.$method = method\n        self.blocking = ! self.async\n        self.js.open(method, url, async)\n    },\n\n    read: function(self){\n        return _read(self)\n    },\n\n    send: function(self, params){\n        // params can be Python dictionary or string\n        var content_type\n        for(var key in self.headers){\n            var header = self.headers[key]\n            self.js.setRequestHeader(header[0], header[1])\n            if(key == 'content-type'){\n                content_type = header[1]\n            }\n        }\n        if((self.encoding || self.blocking) && ! self.hasMimeType){\n            // On blocking mode, or if an encoding has been specified,\n            // override Mime type so that bytes are not processed\n            // (unless the Mime type has been explicitely set)\n            self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        }\n        var res = ''\n        if(! params){\n            self.js.send()\n            return _b_.None\n        }\n        if(isinstance(params, str)){\n            res = params\n        }else if(isinstance(params, dict)){\n            if(content_type == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    add_to_res(res, str.$factory(items[i][0]), items[i][1])\n                }\n            }else{\n                if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                        ! content_type){\n                    // Set default Content-Type for POST requests\n                    self.js.setRequestHeader(\"Content-Type\",\n                        \"application/x-www-form-urlencoded\")\n                }\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    var key = encodeURIComponent(str.$factory(items[i][0]));\n                    if(isinstance(items[i][1], list)){\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' +\n                                encodeURIComponent(str.$factory(items[i][1][j])) + '&'\n                        }\n                    }else{\n                        res += key + '=' +\n                            encodeURIComponent(str.$factory(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0, res.length - 1)\n            }\n        }else{\n            throw _b_.TypeError.$factory(\n                \"send() argument must be string or dictionary, not '\" +\n                str.$factory(params.__class__) + \"'\")\n        }\n        self.js.send(res)\n        return _b_.None\n    },\n\n    set_header: function(self, key, value){\n        self.headers[key.toLowerCase()] = [key, value]\n    },\n\n    set_timeout: function(self, seconds, func){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                func()\n            },\n            seconds * 1000)\n    }\n\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                window.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = self.mode = items.mode,\n        encoding = self.encoding = items.encoding\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n    }\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n        if(key == 'content-type'){\n            content_type = header[1]\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory(),\n        method = 'POST',\n        field_name = 'filetosave'\n\n    if(kw.$string_dict.method !== undefined){\n        method = kw.$string_dict.method[0]\n    }\n\n    if(kw.$string_dict.field_name !== undefined){\n        field_name = kw.$string_dict.field_name[0]\n    }\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    self.js.open(method, url, True)\n    self.js.send(formdata)\n\n    for(key in kw.$string_dict){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$string_dict[key][0])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    $$delete: _delete,\n    file_upload: file_upload,\n    connect,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"]}
__BRYTHON__.update_VFS(scripts)